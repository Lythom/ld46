// Generated by Haxe 3.4.4
if (process.version < "v4.0.0") console.warn("Module " + (typeof(module) == "undefined" ? "" : module.filename) + " requires node.js version 4.0.0 or higher");
(function () { "use strict";
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
};
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var Main = function() { };
Main.__name__ = true;
Main.main = function() {
	var sourceMapSupport = require("source-map-support");
	sourceMapSupport.install();
	var args = Main.args();
	var cwd = args.pop();
	new bind_Cli(args,cwd).run();
};
Main.args = function() {
	var args = [].concat(process.argv.slice(2));
	return args;
};
Math.__name__ = true;
var Reflect = function() { };
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isEnumValue = function(v) {
	if(v != null) {
		return v.__enum__ != null;
	} else {
		return false;
	}
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return HxOverrides.substr(s,0,start.length) == start;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var bind_Type = { __ename__ : true, __constructs__ : ["Void","Int","Float","Bool","String","Array","Map","Object","Function"] };
bind_Type.Void = function(orig) { var $x = ["Void",0,orig]; $x.__enum__ = bind_Type; return $x; };
bind_Type.Int = function(orig) { var $x = ["Int",1,orig]; $x.__enum__ = bind_Type; return $x; };
bind_Type.Float = function(orig) { var $x = ["Float",2,orig]; $x.__enum__ = bind_Type; return $x; };
bind_Type.Bool = function(orig) { var $x = ["Bool",3,orig]; $x.__enum__ = bind_Type; return $x; };
bind_Type.String = function(orig) { var $x = ["String",4,orig]; $x.__enum__ = bind_Type; return $x; };
bind_Type.Array = function(orig) { var $x = ["Array",5,orig]; $x.__enum__ = bind_Type; return $x; };
bind_Type.Map = function(orig) { var $x = ["Map",6,orig]; $x.__enum__ = bind_Type; return $x; };
bind_Type.Object = function(orig) { var $x = ["Object",7,orig]; $x.__enum__ = bind_Type; return $x; };
bind_Type.Function = function(args,ret,orig) { var $x = ["Function",8,args,ret,orig]; $x.__enum__ = bind_Type; return $x; };
var bind_Cli = function(args,cwd) {
	this.args = args;
	this.cwd = cwd;
};
bind_Cli.__name__ = true;
bind_Cli.prototype = {
	run: function() {
		if(this.args.length < 2) {
			process.stdout.write("Usage: haxelib run bind objc SomeHeaderFile.h");
			process.stdout.write("\n");
			return;
		}
		var options_pretty;
		var options_parseOnly;
		var options_json = false;
		options_parseOnly = false;
		options_pretty = false;
		var bindClassOptions = { };
		var fileArgs = [];
		var i = 1;
		while(i < this.args.length) {
			var arg = this.args[i];
			if(StringTools.startsWith(arg,"--")) {
				if(arg == "--json") {
					options_json = true;
				}
				if(arg == "--parse-only") {
					options_parseOnly = true;
				}
				if(arg == "--pretty") {
					options_pretty = true;
				}
				if(arg == "--namespace") {
					++i;
					bindClassOptions["namespace"] = this.args[i];
				}
				if(arg == "--package") {
					++i;
					bindClassOptions.pack = this.args[i];
				}
				if(arg == "--objc-prefix") {
					++i;
					bindClassOptions.objcPrefix = this.args[i];
				}
			} else {
				fileArgs.push(arg);
			}
			++i;
		}
		var kind = this.args[0];
		var json = [];
		var output = "";
		if(kind == "objc") {
			var _g1 = 0;
			var _g = fileArgs.length;
			while(_g1 < _g) {
				var i1 = _g1++;
				var file = fileArgs[i1];
				var path = haxe_io_Path.isAbsolute(file) ? file : haxe_io_Path.join([this.cwd,file]);
				var code = js_node_Fs.readFileSync(path,{ encoding : "utf8"});
				var ctx = { i : 0, types : new haxe_ds_StringMap()};
				var result = null;
				while(true) {
					result = bind_objc_Parse.parseClass(code,ctx);
					if(!(result != null)) {
						break;
					}
					result.path = path;
					if(options_json) {
						if(options_parseOnly) {
							json.push(bind_Json.stringify(result,options_pretty));
						} else {
							var _g2 = 0;
							var _g3 = bind_objc_Bind.bindClass(result,bindClassOptions);
							while(_g2 < _g3.length) {
								var entry = _g3[_g2];
								++_g2;
								json.push(bind_Json.stringify(entry,options_pretty));
							}
						}
					} else if(options_parseOnly) {
						output += "" + Std.string(result);
					} else {
						var _g21 = 0;
						var _g31 = bind_objc_Bind.bindClass(result,bindClassOptions);
						while(_g21 < _g31.length) {
							var entry1 = _g31[_g21];
							++_g21;
							output += "-- BEGIN " + entry1.path + " --\n";
							output += StringTools.rtrim(entry1.content) + "\n\n";
							output += "-- END " + entry1.path + " --\n";
						}
					}
				}
			}
		}
		if(options_json) {
			if(options_pretty) {
				var v = "[" + json.join(",\n") + "]";
				process.stdout.write(v);
				process.stdout.write("\n");
			} else {
				var v1 = "[" + json.join(",") + "]";
				process.stdout.write(v1);
				process.stdout.write("\n");
			}
		} else if(StringTools.trim(output) != "") {
			var v2 = StringTools.rtrim(output);
			process.stdout.write(v2);
			process.stdout.write("\n");
		}
	}
};
var bind_Json = function() { };
bind_Json.__name__ = true;
bind_Json.stringify = function(input,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	return JSON.stringify(bind_Json.toJson(input),null,pretty ? "    " : null);
};
bind_Json.parse = function(input) {
	return bind_Json.fromJson(JSON.parse(input));
};
bind_Json.toJson = function(input) {
	if(input == null) {
		return null;
	} else if((input instanceof Array) && input.__enum__ == null) {
		var array = input;
		var result = [];
		var _g = 0;
		while(_g < array.length) {
			var item = array[_g];
			++_g;
			result.push(bind_Json.toJson(item));
		}
		return result;
	} else if(typeof(input) == "string" || typeof(input) == "number" && ((input | 0) === input) || typeof(input) == "number" || typeof(input) == "boolean") {
		return input;
	} else {
		var result1 = { };
		var _g1 = 0;
		var _g11 = Reflect.fields(input);
		while(_g1 < _g11.length) {
			var key = _g11[_g1];
			++_g1;
			var value = Reflect.field(input,key);
			if(Reflect.isEnumValue(value)) {
				if(key == "type") {
					var res = bind_Json.typeEnumToJson(value);
					result1[key] = res;
				} else {
					result1[key] = null;
				}
			} else {
				result1[key] = bind_Json.toJson(value);
			}
		}
		return result1;
	}
};
bind_Json.typeEnumToJson = function(value) {
	if(value == null) {
		return null;
	}
	var res;
	switch(value[1]) {
	case 0:
		var orig = value[2];
		res = { Void : { orig : bind_Json.toJson(orig)}};
		break;
	case 1:
		var orig1 = value[2];
		res = { Int : { orig : bind_Json.toJson(orig1)}};
		break;
	case 2:
		var orig2 = value[2];
		res = { Float : { orig : bind_Json.toJson(orig2)}};
		break;
	case 3:
		var orig3 = value[2];
		res = { Bool : { orig : bind_Json.toJson(orig3)}};
		break;
	case 4:
		var orig4 = value[2];
		res = { String : { orig : bind_Json.toJson(orig4)}};
		break;
	case 5:
		var orig5 = value[2];
		res = { Array : { orig : bind_Json.toJson(orig5)}};
		break;
	case 6:
		var orig6 = value[2];
		res = { Map : { orig : bind_Json.toJson(orig6)}};
		break;
	case 7:
		var orig7 = value[2];
		res = { Object : { orig : bind_Json.toJson(orig7)}};
		break;
	case 8:
		var orig8 = value[4];
		var ret = value[3];
		var args = value[2];
		res = { Function : { args : bind_Json.toJson(args), ret : bind_Json.typeEnumToJson(ret), orig : bind_Json.toJson(orig8)}};
		break;
	}
	return res;
};
bind_Json.fromJson = function(input) {
	if(input == null) {
		return null;
	} else if((input instanceof Array) && input.__enum__ == null) {
		var array = input;
		var result = [];
		var _g = 0;
		while(_g < array.length) {
			var item = array[_g];
			++_g;
			result.push(bind_Json.fromJson(item));
		}
		return result;
	} else if(typeof(input) == "string" || typeof(input) == "number" && ((input | 0) === input) || typeof(input) == "number" || typeof(input) == "boolean") {
		return input;
	} else {
		var result1 = { };
		var _g1 = 0;
		var _g11 = Reflect.fields(input);
		while(_g1 < _g11.length) {
			var key = _g11[_g1];
			++_g1;
			var value = Reflect.field(input,key);
			var isTypeEnum = false;
			if(key == "type" && value != null && typeof(value) != "string" && !(typeof(input) == "number" && ((input | 0) === input)) && typeof(input) != "number" && typeof(input) != "boolean" && !((input instanceof Array) && input.__enum__ == null)) {
				var subKeys = Reflect.fields(value);
				if(subKeys.length == 1 && subKeys[0].charAt(0).toUpperCase() == subKeys[0].charAt(0)) {
					isTypeEnum = true;
				}
			}
			if(isTypeEnum) {
				var res = bind_Json.typeEnumFromJson(value);
				result1[key] = res;
			} else {
				result1[key] = bind_Json.fromJson(value);
			}
		}
		return result1;
	}
};
bind_Json.typeEnumFromJson = function(value) {
	var name = Reflect.fields(value)[0];
	var params = Reflect.field(value,name);
	switch(name) {
	case "Array":
		return bind_Type.Array(bind_Json.fromJson(params.orig));
	case "Bool":
		return bind_Type.Bool(bind_Json.fromJson(params.orig));
	case "Float":
		return bind_Type.Float(bind_Json.fromJson(params.orig));
	case "Function":
		return bind_Type.Function(bind_Json.fromJson(params.args),bind_Json.fromJson(params.ret),bind_Json.fromJson(params.orig));
	case "Int":
		return bind_Type.Int(bind_Json.fromJson(params.orig));
	case "Map":
		return bind_Type.Map(bind_Json.fromJson(params.orig));
	case "Object":
		return bind_Type.Object(bind_Json.fromJson(params.orig));
	case "String":
		return bind_Type.String(bind_Json.fromJson(params.orig));
	case "Void":
		return bind_Type.Void(bind_Json.fromJson(params.orig));
	default:
		return null;
	}
};
var bind_objc_Bind = function() { };
bind_objc_Bind.__name__ = true;
bind_objc_Bind.createContext = function() {
	return { objcClass : null, indent : 0, files : [], 'namespace' : null, objcPrefix : null, pack : null, currentFile : null};
};
bind_objc_Bind.bindClass = function(objcClass,options) {
	var ctx = bind_objc_Bind.createContext();
	ctx.objcClass = objcClass;
	if(options != null) {
		if(options["namespace"] != null) {
			ctx["namespace"] = options["namespace"];
		}
		if(options.pack != null) {
			ctx.pack = options.pack;
		}
		if(options.objcPrefix != null) {
			ctx.objcPrefix = options.objcPrefix;
		}
	}
	bind_objc_Bind.generateObjCPPFile(ctx,true);
	bind_objc_Bind.generateObjCPPFile(ctx);
	bind_objc_Bind.generateHaxeFile(ctx);
	bind_objc_Bind.generateLincFile(ctx);
	return ctx.files;
};
bind_objc_Bind.generateObjCPPFile = function(ctx,header) {
	if(header == null) {
		header = false;
	}
	var dir = "";
	if(ctx.pack != null && StringTools.trim(ctx.pack) != "") {
		dir = StringTools.replace(ctx.pack,".","/") + "/";
	}
	ctx.currentFile = { path : dir + "linc/linc_" + ctx.objcClass.name + (header ? ".h" : ".mm"), content : ""};
	bind_objc_Bind.writeLine("#import \"hxcpp.h\"",ctx);
	if(!header) {
		bind_objc_Bind.writeLine("#import \"bind_Objc.h\"",ctx);
		bind_objc_Bind.writeLine("#import <Foundation/Foundation.h>",ctx);
		bind_objc_Bind.writeLine("#import \"linc_" + ctx.objcClass.name + ".h\"",ctx);
		bind_objc_Bind.writeLine("#import \"" + ctx.objcClass.name + ".h\"",ctx);
	}
	bind_objc_Bind.writeLineBreak(ctx);
	var namespaceEntries = [];
	if(ctx["namespace"] != null && StringTools.trim(ctx["namespace"]) != "") {
		namespaceEntries = ctx["namespace"].split("::");
	}
	if(ctx.objcClass.description != null && StringTools.trim(ctx.objcClass.description) != "") {
		bind_objc_Bind.writeComment(ctx.objcClass.description,ctx);
		if(namespaceEntries.length == 0) {
			bind_objc_Bind.writeLineBreak(ctx);
		}
	}
	var _g = 0;
	while(_g < namespaceEntries.length) {
		var name = namespaceEntries[_g];
		++_g;
		bind_objc_Bind.writeLine("namespace " + name + " {",ctx);
		ctx.indent++;
		bind_objc_Bind.writeLineBreak(ctx);
	}
	var _g1 = 0;
	var _g11 = ctx.objcClass.methods;
	while(_g1 < _g11.length) {
		var method = _g11[_g1];
		++_g1;
		var isObjcConstructor = bind_objc_Bind.isObjcConstructor(method,ctx);
		var ret = bind_objc_Bind.toHxcppType(method.type,ctx);
		var name1 = method.name;
		var args = [];
		if(method.instance && !isObjcConstructor) {
			args.push("::Dynamic instance_");
		}
		var _g2 = 0;
		var _g3 = method.args;
		while(_g2 < _g3.length) {
			var arg = _g3[_g2];
			++_g2;
			args.push(bind_objc_Bind.toHxcppType(arg.type,ctx) + " " + arg.name);
		}
		if(method.description != null && StringTools.trim(method.description) != "") {
			bind_objc_Bind.writeComment(method.description,ctx);
		}
		bind_objc_Bind.writeIndent(ctx);
		bind_objc_Bind.write(ret + " " + ctx.objcClass.name + "_" + name1 + "(" + args.join(", ") + ")",ctx);
		if(header) {
			bind_objc_Bind.write(";",ctx);
		} else {
			bind_objc_Bind.write(" {",ctx);
			bind_objc_Bind.writeLineBreak(ctx);
			ctx.indent++;
			var i = 0;
			var _g21 = 0;
			var _g31 = method.args;
			while(_g21 < _g31.length) {
				var arg1 = _g31[_g21];
				++_g21;
				bind_objc_Bind.writeObjcArgAssign(arg1,i,ctx);
				++i;
			}
			bind_objc_Bind.writeObjcCall(method,ctx);
			ctx.indent--;
			bind_objc_Bind.writeIndent(ctx);
			bind_objc_Bind.write("}",ctx);
		}
		bind_objc_Bind.writeLineBreak(ctx);
		bind_objc_Bind.writeLineBreak(ctx);
	}
	var _g4 = 0;
	while(_g4 < namespaceEntries.length) {
		var name2 = namespaceEntries[_g4];
		++_g4;
		ctx.indent--;
		bind_objc_Bind.writeLine("}",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
	}
	ctx.files.push(ctx.currentFile);
	ctx.currentFile = null;
};
bind_objc_Bind.generateHaxeFile = function(ctx,header) {
	if(header == null) {
		header = false;
	}
	var reserved = ["new","with"];
	var dir = "";
	if(ctx.pack != null && StringTools.trim(ctx.pack) != "") {
		dir = StringTools.replace(ctx.pack,".","/") + "/";
	}
	var haxeName = ctx.objcClass.name;
	if(ctx.objcPrefix != null && StringTools.trim(ctx.objcPrefix) != "") {
		if(StringTools.startsWith(haxeName,StringTools.trim(ctx.objcPrefix))) {
			haxeName = haxeName.substring(StringTools.trim(ctx.objcPrefix).length);
		}
	}
	ctx.currentFile = { path : dir + haxeName + ".hx", content : ""};
	var packPrefix = "";
	if(ctx.pack != null && StringTools.trim(ctx.pack) != "") {
		packPrefix = StringTools.trim(ctx.pack) + ".";
		bind_objc_Bind.writeLine("package " + StringTools.trim(ctx.pack) + ";",ctx);
	} else {
		bind_objc_Bind.writeLine("package;",ctx);
	}
	bind_objc_Bind.writeLineBreak(ctx);
	if(ctx.objcClass.description != null && StringTools.trim(ctx.objcClass.description) != "") {
		bind_objc_Bind.writeComment(ctx.objcClass.description,ctx);
	}
	bind_objc_Bind.writeLine("class " + haxeName + " {",ctx);
	ctx.indent++;
	bind_objc_Bind.writeLineBreak(ctx);
	bind_objc_Bind.writeLine("private var _instance:Dynamic = null;",ctx);
	bind_objc_Bind.writeLineBreak(ctx);
	bind_objc_Bind.writeLine("public function new() {}",ctx);
	bind_objc_Bind.writeLineBreak(ctx);
	var _g = 0;
	var _g1 = ctx.objcClass.methods;
	while(_g < _g1.length) {
		var method = _g1[_g];
		++_g;
		var isObjcConstructor = bind_objc_Bind.isObjcConstructor(method,ctx);
		var isObjcFactory = bind_objc_Bind.isObjcFactory(method,ctx);
		var ret = bind_objc_Bind.toHaxeType(method.type,ctx);
		var name = method.name;
		if(reserved.indexOf(name) != -1) {
			name = "_" + name;
		}
		var args = [];
		var _g2 = 0;
		var _g3 = method.args;
		while(_g2 < _g3.length) {
			var arg = _g3[_g2];
			++_g2;
			args.push(arg.name + ":" + bind_objc_Bind.toHaxeType(arg.type,ctx));
		}
		if(method.description != null && StringTools.trim(method.description) != "") {
			bind_objc_Bind.writeComment(method.description,ctx);
		}
		bind_objc_Bind.writeIndent(ctx);
		bind_objc_Bind.write("public ",ctx);
		if(!method.instance) {
			bind_objc_Bind.write("static ",ctx);
		}
		bind_objc_Bind.write("function " + name + "(" + args.join(", ") + "):",ctx);
		if(isObjcConstructor) {
			bind_objc_Bind.write(haxeName,ctx);
		} else if(isObjcFactory) {
			bind_objc_Bind.write(haxeName,ctx);
		} else {
			bind_objc_Bind.write(ret,ctx);
		}
		bind_objc_Bind.write(" {",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
		ctx.indent++;
		bind_objc_Bind.writeIndent(ctx);
		if(isObjcConstructor) {
			bind_objc_Bind.write("_instance = ",ctx);
		} else if(isObjcFactory) {
			bind_objc_Bind.write("var ret = new " + haxeName + "();",ctx);
			bind_objc_Bind.writeLineBreak(ctx);
			bind_objc_Bind.writeIndent(ctx);
			bind_objc_Bind.write("ret._instance = ",ctx);
		} else {
			var _g21 = method.type;
			if(_g21[1] == 0) {
				var orig = _g21[2];
			} else {
				bind_objc_Bind.write("return ",ctx);
			}
		}
		bind_objc_Bind.write(ctx.objcClass.name + "_Extern." + name + "(",ctx);
		var i = 0;
		if(!isObjcConstructor && method.instance) {
			bind_objc_Bind.write("_instance",ctx);
			++i;
		}
		var _g22 = 0;
		var _g31 = method.args;
		while(_g22 < _g31.length) {
			var arg1 = _g31[_g22];
			++_g22;
			if(i > 0) {
				bind_objc_Bind.write(", ",ctx);
			}
			bind_objc_Bind.write(arg1.name,ctx);
			++i;
		}
		bind_objc_Bind.write(");",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
		if(isObjcConstructor) {
			bind_objc_Bind.writeLine("return this;",ctx);
		} else if(isObjcFactory) {
			bind_objc_Bind.writeLine("return ret;",ctx);
		}
		ctx.indent--;
		bind_objc_Bind.writeLine("}",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
	}
	ctx.indent--;
	bind_objc_Bind.writeLine("}",ctx);
	bind_objc_Bind.writeLineBreak(ctx);
	bind_objc_Bind.writeLine("@:keep",ctx);
	bind_objc_Bind.writeLine("@:include('linc_" + ctx.objcClass.name + ".h')",ctx);
	bind_objc_Bind.writeLine("#if !display",ctx);
	bind_objc_Bind.writeLine("@:build(bind.Linc.touch())",ctx);
	bind_objc_Bind.writeLine("@:build(bind.Linc.xml('" + ctx.objcClass.name + "', './'))",ctx);
	bind_objc_Bind.writeLine("#end",ctx);
	bind_objc_Bind.writeLine("@:allow(" + packPrefix + haxeName + ")",ctx);
	bind_objc_Bind.writeLine("private extern class " + haxeName + "_Extern {",ctx);
	ctx.indent++;
	bind_objc_Bind.writeLineBreak(ctx);
	var _g4 = 0;
	var _g11 = ctx.objcClass.methods;
	while(_g4 < _g11.length) {
		var method1 = _g11[_g4];
		++_g4;
		var isObjcConstructor1 = bind_objc_Bind.isObjcConstructor(method1,ctx);
		var ret1 = bind_objc_Bind.toHaxeType(method1.type,ctx);
		var name1 = method1.name;
		if(reserved.indexOf(name1) != -1) {
			name1 = "_" + name1;
		}
		var args1 = [];
		if(method1.instance && !isObjcConstructor1) {
			args1.push("instance_:Dynamic");
		}
		var _g23 = 0;
		var _g32 = method1.args;
		while(_g23 < _g32.length) {
			var arg2 = _g32[_g23];
			++_g23;
			args1.push(arg2.name + ":" + bind_objc_Bind.toHaxeType(arg2.type,ctx));
		}
		bind_objc_Bind.writeIndent(ctx);
		bind_objc_Bind.write("@:native('",ctx);
		if(ctx["namespace"] != null && StringTools.trim(ctx["namespace"]) != "") {
			bind_objc_Bind.write(StringTools.trim(ctx["namespace"]) + "::",ctx);
		}
		bind_objc_Bind.write(ctx.objcClass.name + "_" + method1.name,ctx);
		bind_objc_Bind.write("')",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
		bind_objc_Bind.writeIndent(ctx);
		bind_objc_Bind.write("static function " + name1 + "(" + args1.join(", ") + "):" + ret1,ctx);
		bind_objc_Bind.write(";",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
		bind_objc_Bind.writeLineBreak(ctx);
	}
	ctx.indent--;
	bind_objc_Bind.writeLine("}",ctx);
	bind_objc_Bind.writeLineBreak(ctx);
	ctx.files.push(ctx.currentFile);
	ctx.currentFile = null;
};
bind_objc_Bind.generateLincFile = function(ctx,header) {
	if(header == null) {
		header = false;
	}
	var dir = "";
	if(ctx.pack != null && StringTools.trim(ctx.pack) != "") {
		dir = StringTools.replace(ctx.pack,".","/") + "/";
	}
	ctx.currentFile = { path : dir + "linc/linc_" + ctx.objcClass.name + ".xml", content : ""};
	bind_objc_Bind.writeLine("<xml>",ctx);
	ctx.indent++;
	bind_objc_Bind.writeLine("<files id=\"haxe\">",ctx);
	ctx.indent++;
	bind_objc_Bind.writeLine("<compilerflag value=\"-I$" + "{LINC_" + ctx.objcClass.name.toUpperCase() + "_PATH}linc/\" />",ctx);
	bind_objc_Bind.writeLine("<file name=\"$" + "{LINC_" + ctx.objcClass.name.toUpperCase() + "_PATH}linc/linc_" + ctx.objcClass.name + ".mm\" />",ctx);
	ctx.indent--;
	bind_objc_Bind.writeLine("</files>",ctx);
	bind_objc_Bind.writeLine("<target id=\"haxe\">",ctx);
	bind_objc_Bind.writeLine("</target>",ctx);
	ctx.indent--;
	bind_objc_Bind.writeLine("</xml>",ctx);
	ctx.files.push(ctx.currentFile);
	ctx.currentFile = null;
};
bind_objc_Bind.isObjcConstructor = function(method,ctx) {
	var isObjcConstructor = false;
	var objcType = bind_objc_Bind.toObjcType(method.type,ctx);
	if(method.instance && StringTools.startsWith(method.name,"init") && (objcType == "instancetype" || objcType == ctx.objcClass.name + "*")) {
		isObjcConstructor = true;
	}
	return isObjcConstructor;
};
bind_objc_Bind.isObjcFactory = function(method,ctx) {
	var isObjcFactory = false;
	var objcType = bind_objc_Bind.toObjcType(method.type,ctx);
	if(!method.instance && (objcType == "instancetype" || objcType == ctx.objcClass.name + "*")) {
		isObjcFactory = true;
	}
	return isObjcFactory;
};
bind_objc_Bind.toHaxeType = function(type,ctx) {
	var result;
	switch(type[1]) {
	case 0:
		var orig = type[2];
		result = "Void";
		break;
	case 1:
		var orig1 = type[2];
		result = "Int";
		break;
	case 2:
		var orig2 = type[2];
		result = "Float";
		break;
	case 3:
		var orig3 = type[2];
		result = "Bool";
		break;
	case 4:
		var orig4 = type[2];
		result = "String";
		break;
	case 5:
		var orig5 = type[2];
		result = "Array<Dynamic>";
		break;
	case 6:
		var orig6 = type[2];
		result = "Dynamic";
		break;
	case 7:
		var orig7 = type[2];
		result = "Dynamic";
		break;
	case 8:
		var orig8 = type[4];
		var ret = type[3];
		var args = type[2];
		result = bind_objc_Bind.toHaxeFunctionType(type,ctx);
		break;
	}
	return result;
};
bind_objc_Bind.toHaxeFunctionType = function(type,ctx) {
	var result = "Dynamic";
	if(type[1] == 8) {
		var orig = type[4];
		var ret = type[3];
		var args = type[2];
		var resArgs = [];
		if(args.length == 0) {
			resArgs.push("Void");
		} else {
			var _g = 0;
			while(_g < args.length) {
				var arg = args[_g];
				++_g;
				var haxeType = bind_objc_Bind.toHaxeType(arg.type,ctx);
				if(haxeType.indexOf("->") != -1) {
					haxeType = "(" + haxeType + ")";
				}
				resArgs.push(haxeType);
			}
		}
		var haxeType1 = bind_objc_Bind.toHaxeType(ret,ctx);
		if(haxeType1.indexOf("->") != -1) {
			haxeType1 = "(" + haxeType1 + ")";
		}
		resArgs.push(haxeType1);
		result = resArgs.join("->");
	}
	return result;
};
bind_objc_Bind.toHxcppType = function(type,ctx) {
	var result;
	switch(type[1]) {
	case 0:
		var orig = type[2];
		result = "void";
		break;
	case 1:
		var orig1 = type[2];
		result = "int";
		break;
	case 2:
		var orig2 = type[2];
		result = "double";
		break;
	case 3:
		var orig3 = type[2];
		result = "bool";
		break;
	case 4:
		var orig4 = type[2];
		result = "::String";
		break;
	case 5:
		var orig5 = type[2];
		result = bind_objc_Bind.toHxcppArrayType(type,ctx);
		break;
	case 6:
		var orig6 = type[2];
		result = bind_objc_Bind.toHxcppMapType(type,ctx);
		break;
	case 7:
		var orig7 = type[2];
		result = bind_objc_Bind.toHxcppObjectType(type,ctx);
		break;
	case 8:
		var orig8 = type[4];
		var ret = type[3];
		var args = type[2];
		result = bind_objc_Bind.toHxcppFunctionType(type,ctx);
		break;
	}
	return result;
};
bind_objc_Bind.toHxcppArrayType = function(type,ctx) {
	return "::Dynamic";
};
bind_objc_Bind.toHxcppMapType = function(type,ctx) {
	return "::Dynamic";
};
bind_objc_Bind.toHxcppObjectType = function(type,ctx) {
	return "::Dynamic";
};
bind_objc_Bind.toHxcppFunctionType = function(type,ctx) {
	return "::Dynamic";
};
bind_objc_Bind.toObjcType = function(type,ctx) {
	var orig = null;
	switch(type[1]) {
	case 0:
		var orig_ = type[2];
		orig = orig_;
		break;
	case 1:
		var orig_1 = type[2];
		orig = orig_1;
		break;
	case 2:
		var orig_2 = type[2];
		orig = orig_2;
		break;
	case 3:
		var orig_3 = type[2];
		orig = orig_3;
		break;
	case 4:
		var orig_4 = type[2];
		orig = orig_4;
		break;
	case 5:
		var orig_5 = type[2];
		orig = orig_5;
		break;
	case 6:
		var orig_6 = type[2];
		orig = orig_6;
		break;
	case 7:
		var orig_7 = type[2];
		orig = orig_7;
		break;
	case 8:
		var orig_8 = type[4];
		var ret = type[3];
		var args = type[2];
		orig = orig_8;
		break;
	}
	while(orig.orig != null) orig = orig.orig;
	return orig.type;
};
bind_objc_Bind.writeHxcppArgAssign = function(arg,index,ctx) {
	var type = bind_objc_Bind.toHxcppType(arg.type,ctx);
	var name = (arg.name != null ? arg.name : "arg" + (index + 1)) + "_hxcpp_";
	var value = (arg.name != null ? arg.name : "arg" + (index + 1)) + (index == -1 ? "_objc_" : "");
	var _g = arg.type;
	switch(_g[1]) {
	case 1:
		var orig = _g[2];
		bind_objc_Bind.writeIndent(ctx);
		bind_objc_Bind.write("" + type + " " + name + " = (" + type + ") " + value + ";",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
		break;
	case 2:
		var orig1 = _g[2];
		bind_objc_Bind.writeIndent(ctx);
		var objcType = bind_objc_Bind.toObjcType(arg.type,ctx);
		if(objcType == "NSNumber*") {
			bind_objc_Bind.write("" + type + " " + name + " = (" + type + ") ::bind::objc::ObjcIdToHxcpp(" + value + ");",ctx);
		} else {
			bind_objc_Bind.write("" + type + " " + name + " = (" + type + ") " + value + ";",ctx);
		}
		bind_objc_Bind.writeLineBreak(ctx);
		break;
	case 3:
		var orig2 = _g[2];
		bind_objc_Bind.writeIndent(ctx);
		bind_objc_Bind.write("" + type + " " + name + " = (" + type + ") " + value + ";",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
		break;
	case 4:
		var orig3 = _g[2];
		bind_objc_Bind.writeIndent(ctx);
		var objcType1 = bind_objc_Bind.toObjcType(arg.type,ctx);
		switch(objcType1) {
		case "NSMutableString*":case "NSString*":
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::NSStringToHxcpp(" + value + ");",ctx);
			break;
		case "char*":
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::CharStringToHxcpp(" + value + ");",ctx);
			break;
		case "const char*":
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::ConstCharStringToHxcpp(" + value + ");",ctx);
			break;
		}
		bind_objc_Bind.writeLineBreak(ctx);
		break;
	case 8:
		var orig4 = _g[4];
		var ret = _g[3];
		var args = _g[2];
		var funcType = bind_objc_Bind.toHxcppType(arg.type,ctx);
		bind_objc_Bind.writeLine(funcType + " " + name + " = null(); // Not implemented, yet",ctx);
		break;
	default:
		bind_objc_Bind.writeIndent(ctx);
		var objcType2 = bind_objc_Bind.toObjcType(arg.type,ctx);
		if(objcType2 == "instancetype" || objcType2 == ctx.objcClass.name + "*") {
			bind_objc_Bind.write("::Dynamic " + name + " = ::bind::objc::WrappedObjcIdToHxcpp(" + value + ");",ctx);
		} else {
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::ObjcIdToHxcpp(" + value + ");",ctx);
		}
		bind_objc_Bind.writeLineBreak(ctx);
	}
};
bind_objc_Bind.writeObjcArgAssign = function(arg,index,ctx) {
	bind_objc_Bind.writeIndent(ctx);
	var type = bind_objc_Bind.toObjcType(arg.type,ctx);
	var name = (arg.name != null ? arg.name : "arg" + (index + 1)) + "_objc_";
	var value = (arg.name != null ? arg.name : "arg" + (index + 1)) + (index == -1 ? "_hxcpp_" : "");
	var _g = arg.type;
	switch(_g[1]) {
	case 4:
		var orig = _g[2];
		switch(type) {
		case "NSMutableString*":
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::HxcppToNSMutableString(" + value + ");",ctx);
			break;
		case "NSString*":
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::HxcppToNSString(" + value + ");",ctx);
			break;
		case "char*":
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::HxcppToCharString(" + value + ");",ctx);
			break;
		case "const char*":
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::HxcppToConstCharString(" + value + ");",ctx);
			break;
		}
		bind_objc_Bind.writeLineBreak(ctx);
		break;
	case 5:
		var orig1 = _g[2];
		switch(type) {
		case "NSArray*":
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::HxcppToNSArray(" + value + ");",ctx);
			break;
		case "NSMutableArray*":
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::HxcppToNSMutableArray(" + value + ");",ctx);
			break;
		}
		bind_objc_Bind.writeLineBreak(ctx);
		break;
	case 7:
		var orig2 = _g[2];
		if(type == "instancetype" || type == ctx.objcClass.name + "*") {
			bind_objc_Bind.write(ctx.objcClass.name + ("* " + name + " = ::bind::objc::HxcppToUnwrappedObjcId(" + value + ");"),ctx);
		} else if(StringTools.endsWith(type,"*")) {
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::HxcppToObjcId((Dynamic)" + value + ");",ctx);
		} else {
			bind_objc_Bind.write("" + type + " " + name + " = (" + type + ") " + value + ";",ctx);
		}
		bind_objc_Bind.writeLineBreak(ctx);
		break;
	case 8:
		var orig3 = _g[4];
		var ret = _g[3];
		var args = _g[2];
		bind_objc_Bind.write("BindObjcHaxeWrapperClass *" + name + "wrapper_ = [[BindObjcHaxeWrapperClass alloc] init:" + arg.name + ".mPtr];",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
		bind_objc_Bind.writeIndent(ctx);
		var blockReturnType = bind_objc_Bind.toObjcType(ret,ctx);
		bind_objc_Bind.write(blockReturnType + " ",ctx);
		bind_objc_Bind.write("(^" + name + ")(",ctx);
		var i = 0;
		var _g1 = 0;
		while(_g1 < args.length) {
			var blockArg = args[_g1];
			++_g1;
			if(i++ > 0) {
				bind_objc_Bind.write(", ",ctx);
			}
			var argName = blockArg.name;
			if(argName == null) {
				argName = "arg" + i;
			}
			bind_objc_Bind.write(bind_objc_Bind.toObjcType(blockArg.type,ctx) + " " + argName,ctx);
		}
		bind_objc_Bind.write(") = ^" + (blockReturnType != "void" ? blockReturnType : "") + "(",ctx);
		i = 0;
		var _g2 = 0;
		while(_g2 < args.length) {
			var blockArg1 = args[_g2];
			++_g2;
			if(i > 0) {
				bind_objc_Bind.write(", ",ctx);
			}
			var argName1 = blockArg1.name;
			if(argName1 == null) {
				argName1 = "arg" + (i + 1);
			}
			bind_objc_Bind.write(bind_objc_Bind.toObjcType(blockArg1.type,ctx) + " " + argName1,ctx);
			++i;
		}
		bind_objc_Bind.write(") {",ctx);
		ctx.indent++;
		bind_objc_Bind.writeLineBreak(ctx);
		i = 0;
		var _g3 = 0;
		while(_g3 < args.length) {
			var blockArg2 = args[_g3];
			++_g3;
			var argName2 = blockArg2.name;
			if(argName2 == null) {
				argName2 = "arg" + (i + 1);
			}
			var hxcppName = argName2 + "_hxcpp_";
			bind_objc_Bind.writeHxcppArgAssign(blockArg2,i,ctx);
			++i;
		}
		bind_objc_Bind.writeIndent(ctx);
		if(blockReturnType != "void") {
			bind_objc_Bind.write(bind_objc_Bind.toHxcppType(ret,ctx) + " return_hxcpp_ = ",ctx);
		}
		bind_objc_Bind.write(name + "wrapper_->haxeObject->__run(",ctx);
		i = 0;
		var _g4 = 0;
		while(_g4 < args.length) {
			var blockArg3 = args[_g4];
			++_g4;
			if(i > 0) {
				bind_objc_Bind.write(", ",ctx);
			}
			var argName3 = blockArg3.name;
			if(argName3 == null) {
				argName3 = "arg" + (i + 1);
			}
			var hxcppName1 = argName3 + "_hxcpp_";
			bind_objc_Bind.write(hxcppName1,ctx);
			++i;
		}
		bind_objc_Bind.write(");",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
		if(blockReturnType != "void") {
			bind_objc_Bind.writeObjcArgAssign({ name : "return", type : ret},-1,ctx);
			bind_objc_Bind.writeLine("return return_objc_;",ctx);
		}
		ctx.indent--;
		bind_objc_Bind.writeIndent(ctx);
		bind_objc_Bind.write("};",ctx);
		bind_objc_Bind.writeLineBreak(ctx);
		break;
	default:
		if(StringTools.endsWith(type,"*")) {
			bind_objc_Bind.write("" + type + " " + name + " = ::bind::objc::HxcppToObjcId((Dynamic)" + value + ");",ctx);
		} else {
			bind_objc_Bind.write("" + type + " " + name + " = (" + type + ") " + value + ";",ctx);
		}
		bind_objc_Bind.writeLineBreak(ctx);
	}
};
bind_objc_Bind.writeObjcCall = function(method,ctx) {
	var hasReturn = false;
	var hasParenClose = false;
	var isObjcConstructor = bind_objc_Bind.isObjcConstructor(method,ctx);
	bind_objc_Bind.writeIndent(ctx);
	var _g = method.type;
	if(_g[1] == 0) {
		var orig = _g[2];
	} else {
		hasReturn = true;
	}
	if(hasReturn) {
		var _g1 = method.type;
		if(_g1[1] == 8) {
			var orig1 = _g1[4];
			var ret = _g1[3];
			var args = _g1[2];
			bind_objc_Bind.write("id return_objc_ = ",ctx);
		} else {
			var objcType = bind_objc_Bind.toObjcType(method.type,ctx);
			if(objcType == "instancetype") {
				objcType = ctx.objcClass.name + "*";
			}
			bind_objc_Bind.write(objcType + " return_objc_ = ",ctx);
		}
	}
	if(isObjcConstructor) {
		bind_objc_Bind.write("[[" + ctx.objcClass.name + " alloc]",ctx);
	} else if(method.instance) {
		bind_objc_Bind.write("[::bind::objc::HxcppToUnwrappedObjcId(instance_)",ctx);
	} else {
		bind_objc_Bind.write("[" + ctx.objcClass.name,ctx);
	}
	if(method.args.length > 0) {
		var _g11 = 0;
		var _g2 = method.args;
		while(_g11 < _g2.length) {
			var arg = _g2[_g11];
			++_g11;
			var nameSection = arg.orig.nameSection;
			bind_objc_Bind.write(" " + nameSection + ":",ctx);
			bind_objc_Bind.write(arg.name + "_objc_",ctx);
		}
	} else {
		bind_objc_Bind.write(" " + method.name,ctx);
	}
	bind_objc_Bind.write("];",ctx);
	bind_objc_Bind.writeLineBreak(ctx);
	if(hasReturn) {
		bind_objc_Bind.writeHxcppArgAssign({ name : "return", type : method.type},-1,ctx);
		bind_objc_Bind.writeLine("return return_hxcpp_;",ctx);
	}
};
bind_objc_Bind.writeComment = function(comment,ctx) {
	bind_objc_Bind.writeIndent(ctx);
	bind_objc_Bind.write("/** ",ctx);
	var i = 0;
	var lines = comment.split("\n");
	while(i < lines.length) {
		var line = lines[i];
		if(i > 0) {
			bind_objc_Bind.writeLineBreak(ctx);
			bind_objc_Bind.write("    ",ctx);
		}
		bind_objc_Bind.write(line,ctx);
		++i;
	}
	bind_objc_Bind.write(" */",ctx);
	bind_objc_Bind.writeLineBreak(ctx);
};
bind_objc_Bind.writeLine = function(line,ctx) {
	bind_objc_Bind.writeIndent(ctx);
	bind_objc_Bind.write(line,ctx);
	bind_objc_Bind.writeLineBreak(ctx);
};
bind_objc_Bind.writeIndent = function(ctx) {
	var space = "";
	var i = 0;
	var indent = ctx.indent;
	while(i < indent) {
		space += "    ";
		++i;
	}
	bind_objc_Bind.write(space,ctx);
};
bind_objc_Bind.writeLineBreak = function(ctx) {
	bind_objc_Bind.write("\n",ctx);
};
bind_objc_Bind.write = function(input,ctx) {
	ctx.currentFile.content += input;
};
var bind_objc_Parse = function() { };
bind_objc_Parse.__name__ = true;
bind_objc_Parse.createContext = function() {
	return { i : 0, types : new haxe_ds_StringMap()};
};
bind_objc_Parse.parseClass = function(code,ctx) {
	if(ctx == null) {
		ctx = bind_objc_Parse.createContext();
	}
	var i = ctx.i;
	var types = ctx.types;
	if(types == null) {
		types = new haxe_ds_StringMap();
	}
	var c;
	var cc;
	var len = code.length;
	var cleanedCode = bind_objc_Parse.getCodeWithEmptyComments(code);
	var inSingleLineComment = false;
	var inMultilineComment = false;
	var inPreprocessorMacro = false;
	var inInterface = false;
	var comment = null;
	var result = { name : null, path : null, properties : [], methods : [], description : null};
	var lastI = -1;
	while(i < len) {
		if(lastI == i) {
			break;
		}
		lastI = i;
		c = code.charAt(i);
		cc = HxOverrides.substr(code,i,2);
		if(inPreprocessorMacro) {
			if(c == "\n") {
				inPreprocessorMacro = false;
			}
			++i;
		} else if(inSingleLineComment) {
			if(c == "\n") {
				inSingleLineComment = false;
				comment = bind_objc_Parse.cleanComment(comment);
			} else {
				comment += c;
			}
			++i;
		} else if(inMultilineComment) {
			if(cc == "*/") {
				inMultilineComment = false;
				comment = bind_objc_Parse.cleanComment(comment);
				i += 2;
			} else {
				comment += c;
				++i;
			}
		} else if(c == "#") {
			inPreprocessorMacro = true;
			++i;
		} else if(cc == "//") {
			inSingleLineComment = true;
			comment = "";
			i += 2;
		} else if(cc == "/*") {
			inMultilineComment = true;
			comment = "";
			i += 2;
		} else {
			var after = HxOverrides.substr(code,i,null);
			if(c == "@") {
				if(inInterface) {
					if(StringTools.startsWith(after,"@property")) {
						ctx.i = i;
						var property = bind_objc_Parse.parseProperty(cleanedCode,ctx);
						i = ctx.i;
						if(property == null) {
							var v = "invalid property: " + code.substring(i,ctx.i);
							process.stdout.write(v);
							process.stdout.write("\n");
						} else {
							if(comment != null) {
								property.description = comment;
							}
							result.properties.push(property);
						}
						comment = null;
					} else if(StringTools.startsWith(after,"@end")) {
						inInterface = false;
						i += 4;
						break;
					}
				} else if(StringTools.startsWith(after,"@interface")) {
					ctx.i = i;
					var className = bind_objc_Parse.parseClassName(cleanedCode,ctx);
					i = ctx.i;
					if(className == null) {
						process.stdout.write("invalid interface");
						process.stdout.write("\n");
						break;
					}
					inInterface = true;
					result.name = className;
					if(comment != null) {
						result.description = comment;
						comment = null;
					}
				} else {
					++i;
				}
			} else if(inInterface && (c == "-" || c == "+")) {
				ctx.i = i;
				var method = bind_objc_Parse.parseMethod(cleanedCode,ctx);
				i = ctx.i;
				if(method == null) {
					var v1 = "invalid method: " + code.substring(i,ctx.i);
					process.stdout.write(v1);
					process.stdout.write("\n");
				} else {
					if(comment != null) {
						method.description = comment;
					}
					result.methods.push(method);
				}
				comment = null;
			} else if(StringTools.startsWith(after,"typedef")) {
				ctx.i = i;
				var type = bind_objc_Parse.parseTypedef(cleanedCode,ctx);
				i = ctx.i;
				if(type == null) {
					var v2 = "invalid typedef: " + code.substring(i,ctx.i);
					process.stdout.write(v2);
					process.stdout.write("\n");
				}
				comment = null;
			} else {
				++i;
			}
		}
	}
	ctx.i = i;
	if(result.name != null) {
		return result;
	} else {
		return null;
	}
};
bind_objc_Parse.parseProperty = function(code,ctx) {
	if(ctx == null) {
		ctx = bind_objc_Parse.createContext();
	}
	var i = ctx.i;
	var after = HxOverrides.substr(code,i,null);
	if(bind_objc_Parse.RE_PROPERTY.match(after)) {
		var objcModifiers = bind_objc_Parse.RE_PROPERTY.matched(1) != null ? bind_objc_Parse.RE_PROPERTY.matched(1).split(",").map(function(s) {
			return StringTools.trim(s);
		}) : [];
		var objcType = bind_objc_Parse.removeSpacesForType(bind_objc_Parse.RE_PROPERTY.matched(2));
		var objcName = bind_objc_Parse.RE_PROPERTY.matched(3) != null ? StringTools.trim(bind_objc_Parse.RE_PROPERTY.matched(3)) : null;
		var name = null;
		var type = null;
		if(objcName == null) {
			objcName = StringTools.trim(bind_objc_Parse.RE_PROPERTY.matched(4));
			var objcArgs = bind_objc_Parse.RE_PROPERTY.matched(5) != null && StringTools.trim(bind_objc_Parse.RE_PROPERTY.matched(5)) != "" ? bind_objc_Parse.RE_PROPERTY.matched(5).split(",").map(function(s1) {
				return StringTools.trim(s1);
			}) : [];
			var args = [];
			var _g = 0;
			while(_g < objcArgs.length) {
				var objcArg = objcArgs[_g];
				++_g;
				args.push(bind_objc_Parse.parseArg(objcArg,ctx));
			}
			type = bind_Type.Function(args,bind_objc_Parse.parseType(objcType,{ i : 0, types : ctx.types}));
		} else {
			type = bind_objc_Parse.parseType(objcType,{ i : 0, types : ctx.types});
		}
		name = objcName;
		ctx.i += bind_objc_Parse.RE_PROPERTY.matched(0).length;
		var nullable;
		switch(type[1]) {
		case 1:
			var orig = type[2];
			if(!(objcModifiers.indexOf("nullable") != -1 || objcModifiers.indexOf("_Nullable") != -1)) {
				nullable = objcModifiers.indexOf("__nullable") != -1;
			} else {
				nullable = true;
			}
			break;
		case 2:
			var orig1 = type[2];
			if(!(objcModifiers.indexOf("nullable") != -1 || objcModifiers.indexOf("_Nullable") != -1)) {
				nullable = objcModifiers.indexOf("__nullable") != -1;
			} else {
				nullable = true;
			}
			break;
		case 3:
			var orig2 = type[2];
			if(!(objcModifiers.indexOf("nullable") != -1 || objcModifiers.indexOf("_Nullable") != -1)) {
				nullable = objcModifiers.indexOf("__nullable") != -1;
			} else {
				nullable = true;
			}
			break;
		default:
			if(objcModifiers.indexOf("nonnull") == -1 && objcModifiers.indexOf("_Nullable") == -1) {
				nullable = objcModifiers.indexOf("__nullable") == -1;
			} else {
				nullable = false;
			}
		}
		return { name : name, type : type, instance : true, description : null, orig : { nullable : nullable}};
	} else {
		var semicolonIndex = after.indexOf(";");
		if(semicolonIndex == -1) {
			ctx.i += after.length;
		} else {
			ctx.i += semicolonIndex;
		}
		return null;
	}
};
bind_objc_Parse.parseMethod = function(code,ctx) {
	if(ctx == null) {
		ctx = bind_objc_Parse.createContext();
	}
	var i = ctx.i;
	var after;
	var len = code.length;
	var c;
	var lastI = -1;
	var sign = null;
	var returnType = null;
	var name = null;
	var args = [];
	var nameSection = null;
	var fullNameSections = [];
	while(i < len) {
		c = code.charAt(i);
		after = HxOverrides.substr(code,i,null);
		if(StringTools.trim(c) == "") {
			++i;
		} else if(sign == null) {
			if(c == "+" || c == "-") {
				sign = c;
				++i;
				continue;
			}
			return null;
		} else if(returnType == null) {
			if(c == "(") {
				++i;
				c = code.charAt(i);
				while(StringTools.trim(c) == "") {
					++i;
					c = code.charAt(i);
				}
				after = HxOverrides.substr(code,i,null);
				if(bind_objc_Parse.RE_TYPE.match(after)) {
					var objcReturnType = bind_objc_Parse.RE_TYPE.matched(0);
					returnType = bind_objc_Parse.parseType(objcReturnType,{ i : 0, types : ctx.types});
					i += objcReturnType.length;
					while(StringTools.trim(code.charAt(i)) == "") ++i;
					if(code.charAt(i) == ")") {
						++i;
						continue;
					}
				}
			}
			return null;
		} else if(name == null) {
			if(bind_objc_Parse.RE_IDENTIFIER.match(after)) {
				var objcName = bind_objc_Parse.RE_IDENTIFIER.matched(0);
				name = StringTools.trim(objcName);
				nameSection = name;
				fullNameSections.push(nameSection);
				i += objcName.length;
				continue;
			}
			return null;
		} else if(nameSection == null) {
			if(c == ";") {
				++i;
				break;
			} else if(bind_objc_Parse.RE_IDENTIFIER.match(after)) {
				nameSection = bind_objc_Parse.RE_IDENTIFIER.matched(0);
				fullNameSections.push(nameSection);
				continue;
			}
			return null;
		} else if(c == ";") {
			++i;
			break;
		} else if(c == ":") {
			++i;
			while(StringTools.trim(code.charAt(i)) == "") ++i;
			if(code.charAt(i) == "(") {
				++i;
				while(StringTools.trim(code.charAt(i)) == "") ++i;
				after = HxOverrides.substr(code,i,null);
				if(bind_objc_Parse.RE_TYPE.match(after)) {
					var objcType = bind_objc_Parse.RE_TYPE.matched(0);
					var argType = bind_objc_Parse.parseType(objcType,{ i : 0, types : ctx.types});
					i += objcType.length;
					if(argType != null) {
						while(StringTools.trim(code.charAt(i)) == "") ++i;
						if(code.charAt(i) == ")") {
							++i;
							while(StringTools.trim(code.charAt(i)) == "") ++i;
							after = HxOverrides.substr(code,i,null);
							if(bind_objc_Parse.RE_IDENTIFIER.match(after)) {
								var argName = StringTools.trim(bind_objc_Parse.RE_IDENTIFIER.matched(0));
								i += argName.length;
								args.push({ name : argName, type : argType, orig : { nameSection : nameSection}});
								nameSection = null;
								continue;
							}
						}
					}
				}
			}
			return null;
		} else {
			++i;
		}
	}
	ctx.i = i;
	if(name == null) {
		return null;
	}
	return { name : name, instance : sign == "-", description : null, type : returnType, args : args};
};
bind_objc_Parse.parseArg = function(objcArg,parentCtx) {
	if(parentCtx == null) {
		parentCtx = bind_objc_Parse.createContext();
	}
	var ctx = { i : 0, types : parentCtx.types};
	var type = bind_objc_Parse.parseType(objcArg,ctx);
	if(type == null) {
		return null;
	}
	var remaining = HxOverrides.substr(objcArg,ctx.i,null);
	var name = null;
	if(bind_objc_Parse.RE_IDENTIFIER.match(remaining)) {
		name = bind_objc_Parse.RE_IDENTIFIER.matched(0);
	}
	return { type : type, name : name};
};
bind_objc_Parse.parseType = function(objcType,ctx) {
	if(ctx == null) {
		ctx = bind_objc_Parse.createContext();
	}
	if(ctx.i > 0) {
		objcType = HxOverrides.substr(objcType,ctx.i,null);
	}
	if(bind_objc_Parse.RE_TYPE.match(objcType)) {
		var type = null;
		ctx.i += bind_objc_Parse.RE_TYPE.matched(0).length;
		if(bind_objc_Parse.RE_TYPE.matched(5) != null) {
			var objcReturnType = bind_objc_Parse.removeSpacesForType(bind_objc_Parse.removeNullabilityForType(bind_objc_Parse.RE_TYPE.matched(1)));
			var objcNullability = bind_objc_Parse.RE_TYPE.matched(3);
			var objcModifiers = [];
			if(bind_objc_Parse.RE_TYPE.matched(2) != null) {
				var _g = 0;
				var _g1 = StringTools.replace(bind_objc_Parse.RE_TYPE.matched(2),"\t"," ").split(" ");
				while(_g < _g1.length) {
					var part = _g1[_g];
					++_g;
					objcModifiers.push(StringTools.trim(part));
				}
			}
			if(objcNullability == null || StringTools.trim(objcNullability) == "") {
				if(objcModifiers.indexOf("_Nonnull") != -1) {
					objcNullability = "_Nonnull";
				} else if(objcModifiers.indexOf("nonnull") != -1) {
					objcNullability = "nonnull";
				} else if(objcModifiers.indexOf("__nonnull") != -1) {
					objcNullability = "__nonnull";
				}
			}
			var objcArgs = bind_objc_Parse.RE_TYPE.matched(6) != null && StringTools.trim(bind_objc_Parse.RE_TYPE.matched(6)) != "" ? bind_objc_Parse.RE_TYPE.matched(6).split(",").map(function(s) {
				return StringTools.trim(s);
			}) : [];
			var args = [];
			var _g2 = 0;
			while(_g2 < objcArgs.length) {
				var objcArg = objcArgs[_g2];
				++_g2;
				args.push(bind_objc_Parse.parseArg(objcArg,ctx));
			}
			return bind_Type.Function(args,bind_objc_Parse.parseType(objcReturnType,{ i : 0, types : ctx.types}),{ type : objcType, nullable : objcNullability != "_Nonnull" && objcNullability != "nonnull" && objcNullability != "__nonnull"});
		} else {
			var objcType1 = bind_objc_Parse.removeSpacesForType(bind_objc_Parse.removeNullabilityForType(bind_objc_Parse.RE_TYPE.matched(1)));
			var objcNullability1 = bind_objc_Parse.RE_TYPE.matched(4);
			var objcModifiers1 = [];
			if(bind_objc_Parse.RE_TYPE.matched(2) != null) {
				var _g3 = 0;
				var _g11 = StringTools.replace(bind_objc_Parse.RE_TYPE.matched(2),"\t"," ").split(" ");
				while(_g3 < _g11.length) {
					var part1 = _g11[_g3];
					++_g3;
					objcModifiers1.push(StringTools.trim(part1));
				}
			}
			if(objcNullability1 == null || StringTools.trim(objcNullability1) == "") {
				if(objcModifiers1.indexOf("_Nonnull") != -1) {
					objcNullability1 = "_Nonnull";
				} else if(objcModifiers1.indexOf("nonnull") != -1) {
					objcNullability1 = "nonnull";
				} else if(objcModifiers1.indexOf("__nonnull") != -1) {
					objcNullability1 = "__nonnull";
				}
			}
			var notNonNull = objcNullability1 != "_Nonnull" && objcNullability1 != "nonnull" && objcNullability1 != "__nonnull";
			var hasNullable = objcNullability1 == "_Nonnull" || objcNullability1 == "nonnull" || objcNullability1 == "__nonnull";
			var _this = ctx.types;
			var matchedType = __map_reserved[objcType1] != null ? _this.getReserved(objcType1) : _this.h[objcType1];
			if(matchedType != null) {
				switch(matchedType[1]) {
				case 0:
					var orig = matchedType[2];
					return bind_Type.Void({ orig : orig, type : objcType1, nullable : hasNullable || orig.nullable});
				case 1:
					var orig1 = matchedType[2];
					return bind_Type.Int({ orig : orig1, type : objcType1, nullable : hasNullable || orig1.nullable});
				case 2:
					var orig2 = matchedType[2];
					return bind_Type.Float({ orig : orig2, type : objcType1, nullable : hasNullable || orig2.nullable});
				case 3:
					var orig3 = matchedType[2];
					return bind_Type.Bool({ orig : orig3, type : objcType1, nullable : hasNullable || orig3.nullable});
				case 4:
					var orig4 = matchedType[2];
					return bind_Type.String({ orig : orig4, type : objcType1, nullable : notNonNull || orig4.nullable});
				case 5:
					var orig5 = matchedType[2];
					return bind_Type.Array({ orig : orig5, type : objcType1, nullable : notNonNull || orig5.nullable});
				case 6:
					var orig6 = matchedType[2];
					return bind_Type.Map({ orig : orig6, type : objcType1, nullable : notNonNull || orig6.nullable});
				case 7:
					var orig7 = matchedType[2];
					return bind_Type.Object({ orig : orig7, type : objcType1, nullable : notNonNull || orig7.nullable});
				case 8:
					var orig8 = matchedType[4];
					var ret = matchedType[3];
					var args1 = matchedType[2];
					return bind_Type.Function(args1,ret,{ orig : orig8, type : objcType1, nullable : notNonNull || orig8.nullable});
				}
			}
			switch(objcType1) {
			case "BOOL":case "bool":
				return bind_Type.Bool({ type : objcType1, nullable : hasNullable});
			case "NSDictionary*":case "NSMutableDictionary*":
				return bind_Type.Map({ type : objcType1, nullable : notNonNull});
			case "NSArray*":case "NSMutableArray*":
				return bind_Type.Array({ type : objcType1, nullable : notNonNull});
			case "NSNumber*":
				return bind_Type.Float({ type : objcType1, nullable : notNonNull});
			case "NSMutableString*":case "NSString*":case "char*":case "const char*":
				return bind_Type.String({ type : objcType1, nullable : notNonNull});
			case "CGFloat":case "NSTimeInterval":case "double":case "float":case "long double":
				return bind_Type.Float({ type : objcType1, nullable : hasNullable});
			case "NSInteger":case "char":case "int":case "long":case "long int":case "long long":case "long long int":case "short":case "short int":case "signed":case "signed char":case "signed int":case "signed long":case "signed long int":case "signed long long":case "signed long long int":case "signed short":case "signed short int":case "unsigned":case "unsigned char":case "unsigned int":case "unsigned long":case "unsigned long int":case "unsigned long long":case "unsigned long long int":case "unsigned short":case "unsigned short int":
				return bind_Type.Int({ type : objcType1, nullable : hasNullable});
			case "void":
				return bind_Type.Void({ type : objcType1, nullable : hasNullable});
			default:
				return bind_Type.Object({ type : objcType1, nullable : notNonNull});
			}
		}
	}
	return null;
};
bind_objc_Parse.parseTypedef = function(code,ctx) {
	if(ctx == null) {
		ctx = bind_objc_Parse.createContext();
	}
	var i = ctx.i;
	var after;
	var len = code.length;
	var after1 = HxOverrides.substr(code,i,null);
	if(bind_objc_Parse.RE_TYPEDEF.match(after1)) {
		i += bind_objc_Parse.RE_TYPEDEF.matched(0).length;
		if(ctx != null) {
			ctx.i = i;
		}
		var nameFromBlock = bind_objc_Parse.RE_TYPEDEF.matched(3);
		var nameAtEnd = bind_objc_Parse.RE_TYPEDEF.matched(6);
		var objcType = bind_objc_Parse.RE_TYPEDEF.matched(1);
		if(nameFromBlock == null && nameAtEnd == null) {
			if(bind_objc_Parse.RE_TYPEDEF_NAME.match(objcType)) {
				nameAtEnd = StringTools.trim(bind_objc_Parse.RE_TYPEDEF_NAME.matched(0));
				objcType = objcType.substring(0,objcType.length - nameAtEnd.length);
			} else {
				return null;
			}
		}
		if(nameFromBlock != null) {
			objcType = objcType.replace(bind_objc_Parse.RE_TYPEDEF_BLOCK_NAME.r,"(^)");
		}
		var name = nameFromBlock;
		if(name == null) {
			name = nameAtEnd;
		}
		objcType = bind_objc_Parse.removeSpacesForType(objcType);
		var type = bind_objc_Parse.parseType(objcType,{ i : 0, types : ctx.types});
		var _this = ctx.types;
		if(__map_reserved[name] != null) {
			_this.setReserved(name,type);
		} else {
			_this.h[name] = type;
		}
		return type;
	}
	return null;
};
bind_objc_Parse.parseClassName = function(code,ctx) {
	if(ctx == null) {
		ctx = bind_objc_Parse.createContext();
	}
	var i = ctx.i;
	var after = HxOverrides.substr(code,i,null);
	if(bind_objc_Parse.RE_INTERFACE.match(after)) {
		var name = StringTools.trim(bind_objc_Parse.RE_INTERFACE.matched(1));
		var parent = bind_objc_Parse.removeSpaces(bind_objc_Parse.RE_INTERFACE.matched(2));
		var category = bind_objc_Parse.removeSpaces(bind_objc_Parse.RE_INTERFACE.matched(3));
		var protocols = bind_objc_Parse.RE_INTERFACE.matched(4) != null ? bind_objc_Parse.RE_INTERFACE.matched(4).split(",").map(function(s) {
			return StringTools.trim(s);
		}) : [];
		ctx.i += bind_objc_Parse.RE_INTERFACE.matched(0).length;
		return name;
	}
	return null;
};
bind_objc_Parse.removeSpaces = function(input) {
	if(input == null) {
		return null;
	}
	return input.replace(bind_objc_Parse.RE_ALL_SPACES.r,"");
};
bind_objc_Parse.removeSpacesForType = function(input) {
	if(input == null) {
		return null;
	}
	if(bind_objc_Parse.RE_C_MODIFIERS.match(input)) {
		var prefix = bind_objc_Parse.RE_C_MODIFIERS.matched(0);
		var suffix = HxOverrides.substr(input,prefix.length,null);
		prefix = prefix.replace(bind_objc_Parse.RE_ALL_SPACES.r," ");
		return StringTools.trim(prefix + suffix.replace(bind_objc_Parse.RE_ALL_SPACES.r,""));
	}
	return StringTools.trim(input.replace(bind_objc_Parse.RE_ALL_SPACES.r,""));
};
bind_objc_Parse.removeNullabilityForType = function(input) {
	if(input == null) {
		return null;
	}
	return StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(StringTools.replace(input,"_Nonnull",""),"nonnull",""),"__nonnull",""),"_Nullable",""),"nullable",""),"__nullable",""),"_Null_unspecified",""),"__null_unspecified","");
};
bind_objc_Parse.getCodeWithEmptyComments = function(input) {
	var i = 0;
	var output = "";
	var len = input.length;
	var inSingleLineComment = false;
	var inMultilineComment = false;
	var k;
	var c;
	var cc;
	while(i < len) {
		c = input.charAt(i);
		cc = HxOverrides.substr(input,i,2);
		if(inSingleLineComment) {
			if(c == "\n") {
				inSingleLineComment = false;
				output += "\n";
			} else {
				output += " ";
			}
			++i;
		} else if(inMultilineComment) {
			if(cc == "*/") {
				inMultilineComment = false;
				output += "  ";
				i += 2;
			} else {
				if(c == "\n") {
					output += "\n";
				} else {
					output += " ";
				}
				++i;
			}
		} else if(cc == "//") {
			inSingleLineComment = true;
			output += "  ";
			i += 2;
		} else if(cc == "/*") {
			inMultilineComment = true;
			output += "  ";
			i += 2;
		} else {
			output += c;
			++i;
		}
	}
	return output;
};
bind_objc_Parse.cleanComment = function(comment) {
	var lines = [];
	var _g = 0;
	var _g1 = comment.split("\n");
	while(_g < _g1.length) {
		var line = _g1[_g];
		++_g;
		line = line.replace(bind_objc_Parse.RE_BEFORE_COMMENT_LINE.r,"");
		line = line.replace(bind_objc_Parse.RE_AFTER_COMMENT_LINE.r,"");
		lines.push(line);
	}
	return StringTools.trim(lines.join("\n"));
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
};
var haxe_io_Bytes = function() { };
haxe_io_Bytes.__name__ = true;
var haxe_io_Path = function() { };
haxe_io_Path.__name__ = true;
haxe_io_Path.join = function(paths) {
	var paths1 = paths.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g1 = 1;
	var _g = paths1.length;
	while(_g1 < _g) {
		var i = _g1++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var regex_r = new RegExp("([^:])/+","g".split("u").join(""));
	var result = tmp.replace(regex_r,"$1" + slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g11 = 0;
	var _g2 = tmp.length;
	while(_g11 < _g2) {
		var i = _g11++;
		var _g21 = tmp.charCodeAt(i);
		switch(_g21) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i1 = _g21;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCharCode(i1);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i2 = _g21;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCharCode(i2);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
haxe_io_Path.isAbsolute = function(path) {
	if(StringTools.startsWith(path,"/")) {
		return true;
	}
	if(path.charAt(1) == ":") {
		return true;
	}
	if(StringTools.startsWith(path,"\\\\")) {
		return true;
	}
	return false;
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_node_Fs = require("fs");
var js_node_buffer_Buffer = require("buffer").Buffer;
String.__name__ = true;
Array.__name__ = true;
var __map_reserved = {};
bind_objc_Parse.RE_ALL_SPACES = new EReg("\\s+","g");
bind_objc_Parse.RE_BEFORE_COMMENT_LINE = new EReg("^[\\s\\*]*(//)?\\s*","g");
bind_objc_Parse.RE_AFTER_COMMENT_LINE = new EReg("[\\s\\*]*$","g");
bind_objc_Parse.RE_C_MODIFIERS = new EReg("^\\s*(?:(?:const|signed|unsigned|short|long|nullable|nonnull|_Nullable|_Nonnull|_Null_unspecified|__nullable|__nonnull|__null_unspecified)\\s+)*","");
bind_objc_Parse.RE_TYPEDEF_BLOCK_NAME = new EReg("(?:\\(\\s*\\^\\s*(?:[a-zA-Z_][a-zA-Z0-9_]*)\\s*\\))","");
bind_objc_Parse.RE_TYPEDEF_NAME = new EReg("\\s+([a-zA-Z_][a-zA-Z0-9_]*)?\\s*$","");
bind_objc_Parse.RE_TYPE = new EReg("^((?:(const|signed|unsigned|short|long|nullable|nonnull|_Nullable|_Nonnull|_Null_unspecified|__nullable|__nonnull|__null_unspecified)\\s+)*[a-zA-Z_][a-zA-Z0-9_]*(?:\\s*<\\s*[a-zA-Z_][a-zA-Z0-9_]*\\s*>)?[\\*\\s]*)(?:\\(\\s*\\^\\s*(_Nullable|_Nonnull|nullable|nonnull|_Null_unspecified|__nullable|__nonnull|__null_unspecified)?\\s*\\)|(_Nullable|_Nonnull|nullable|nonnull|_Null_unspecified|__nullable|__nonnull|__null_unspecified)?)\\s*(\\(\\s*((?:(?:const|signed|unsigned|short|long|nullable|nonnull|_Nullable|_Nonnull|_Null_unspecified|__nullable|__nonnull|__null_unspecified)\\s+)*(?:[a-zA-Z_][a-zA-Z0-9_]*(?:\\s*<\\s*[a-zA-Z_][a-zA-Z0-9_]*\\s*>)?[\\*\\s]*(?:[a-zA-Z_][a-zA-Z0-9_]*)?\\s*,?\\s*)*)?\\s*\\))?\\s*","");
bind_objc_Parse.RE_TYPEDEF = new EReg("^typedef\\s+(((?:(?:const|signed|unsigned|short|long|nullable|nonnull|_Nullable|_Nonnull|_Null_unspecified|__nullable|__nonnull|__null_unspecified)\\s+)*[a-zA-Z_][a-zA-Z0-9_]*(?:\\s*<\\s*[a-zA-Z_][a-zA-Z0-9_]*\\s*>)?[\\*\\s]*)(?:\\(\\s*\\^\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\))?\\s*(\\(\\s*((?:[a-zA-Z_][a-zA-Z0-9_]*(?:\\s*<\\s*[a-zA-Z_][a-zA-Z0-9_]*\\s*>)?[\\*\\s]*(?:[a-zA-Z_][a-zA-Z0-9_]*)?\\s*,?\\s*)*)?\\s*\\))?)\\s*([a-zA-Z_][a-zA-Z0-9_]*)?\\s*;","");
bind_objc_Parse.RE_IDENTIFIER = new EReg("^[a-zA-Z_][a-zA-Z0-9_]*","");
bind_objc_Parse.RE_PROPERTY = new EReg("^@property\\s*(?:\\((\\s*(?:[a-z]+\\s*,?\\s*)*)\\))?\\s*((?:(?:const|signed|unsigned|short|long|nullable|nonnull|_Nullable|_Nonnull|_Null_unspecified|__nullable|__nonnull|__null_unspecified)\\s+)*[a-zA-Z_][a-zA-Z0-9_]*(?:\\s*<\\s*[a-zA-Z_][a-zA-Z0-9_]*\\s*>)?[\\*\\s]*)(?:([a-zA-Z_][a-zA-Z0-9_]*)|\\(\\s*\\^\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*\\)\\s*\\(\\s*((?:(?:const|signed|unsigned|short|long|nullable|nonnull|_Nullable|_Nonnull|_Null_unspecified|__nullable|__nonnull|__null_unspecified)\\s+)*(?:[a-zA-Z_][a-zA-Z0-9_<>\\s\\*]*[\\s\\*]?(?:[a-zA-Z_][a-zA-Z0-9_]*)?\\s*,?\\s*)*)?\\s*\\))\\s*;","");
bind_objc_Parse.RE_INTERFACE = new EReg("^@interface\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?::\\s*([a-zA-Z_][a-zA-Z0-9_]*))?\\s*(?:\\(\\s*([a-zA-Z_][a-zA-Z0-9_]*)?\\s*\\))?\\s*(?:<(\\s*(?:[a-zA-Z_][a-zA-Z0-9_]*\\s*,?\\s*)*)>)?","");
Main.main();
})();

//# sourceMappingURL=index.js.map